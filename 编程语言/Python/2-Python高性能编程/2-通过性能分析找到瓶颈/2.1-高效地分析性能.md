# 高效地分析性能

- [高效地分析性能](#高效地分析性能)
  - [计时的简单方法](#计时的简单方法)
    - [time.time() 函数](#timetime-函数)
    - [基于 time.time() 的装饰器](#基于-timetime-的装饰器)
    - [timeit模块](#timeit模块)
    - [UNIX 的 time 命令](#unix-的-time-命令)
    - [cProfile 模块](#cprofile-模块)

性能调优包括：

- 在速度上的提升
- 减少资源的占用

## 计时的简单方法

### time.time() 函数

```python
from time import time

start_time = time()
# ...
end_time = time()
secs = end_time - start_time
print(f"cost {secs} seconds.")
```

### 基于 time.time() 的装饰器

```python
from time import time
from functools import wraps

def timer(fun):
    @wraps(fun)
    def wrapper(*args, **kwargs):
        start_time = time()
        result = fun(*args, **kwargs)
        end_time = time()
        secs = end_time - start_time
        print(f"func {fun.__name__} cost {secs} seconds.")
        return result
    return wrapper
```

### timeit模块

演示代码为 test.py，其内容如下：

```python
from time import time, sleep

def a():
    start_time = time()
    sleep(3)
    end_time = time()
    secs = end_time - start_time
    print(f"cost {secs} seconds.")

if __name__ == "__main__":
    a()
```

在 test.py 所在目录下执行以下命令：

```bash
$ python -m timeit -n 5 -r 3 -s "import test" "test.a()"
cost 3.0032098293304443 seconds.
cost 3.0032477378845215 seconds.
cost 3.0033299922943115 seconds.
cost 3.003307342529297 seconds.
cost 3.003286123275757 seconds.
cost 3.0032942295074463 seconds.
cost 3.0032079219818115 seconds.
cost 3.0032875537872314 seconds.
cost 3.003225326538086 seconds.
cost 3.0032753944396973 seconds.
cost 3.003242015838623 seconds.
cost 3.0034122467041016 seconds.
cost 3.0031585693359375 seconds.
cost 3.0033297538757324 seconds.
cost 3.0030765533447266 seconds.
5 loops, best of 3: 3 sec per loop
```

这个命令参数含义如下：

- `-n 5`：设置执行被计时的语句的次数为 5（默认为 5 次）
- `-r 3`：设置重复定时器的次数（默认为 5 次）
- `-s "import test"`：设置最初要执行一次的语句为 "import test"（默认为 "pass"，这个设置语句的执行时间不被计时）
- `"test.a()"`：设置被计时的语句为 "test.a()"（默认为 "pass"）

命令详细使用方法可使用 `python -m timeit -h` 查看。

> **注：** `timeit` 模块暂时禁用了垃圾收集器。如果你的操作会调用到垃圾收集器，那么它有可能影响到你实际操作的速度。

### UNIX 的 time 命令

使用的演示代码还是和 [timeit 模块](#timeit-模块) 中的一样。

```bash
$ /usr/bin/time -p python test.py
cost 3.0033321380615234 seconds.
real 3.05
user 0.03
sys 0.02
```

注意我们特地使用了 `/usr/bin/time` 而不是 `time`，也就是说我们使用的是系统命令的 `time` 而不是那个更加简单而没用的 shell 内建版本的 `time`。如果你用 `time --verbose`，结果得到一个错误，那么你使用的可能就是 shell 内建的 `time` 而不是系统命令的 `time`。

通过使用 `-p` 参数，我们得到了 3 个结果：

- `real`：记录了整体的耗时
- `user`：记录了 CPU 花在任务上的时间，但不包括内核函数耗费的时间
- `sys`：记录了内核函数耗费的时间

对 `user` 和 `sys` 相加就得到了 CPU 总共花费的时间。而这个时间和 `real` 的差则有可能是花费在等待 IO 上，也可能是你的系统正在忙着运行其他任务因此影响了你的测量。

`time` 并不是专为 Python 脚本使用的。它还包括了启动 Python 解释器的时间，如果你会启动很多新进程（而不是一个长期运行的单一进程），这个时间可能会很长。

如果你会经常跑一些临时脚本，它们的启动时间占了整体运行时间的很大一部分，那么 `time` 更适合测量这种情况。

我们可以使用 `--verbose` 参数来获得更多输出信息：

```bash
$ /usr/bin/time --verbose python test.py
cost 3.0032918453216553 seconds.
        Command being timed: "python test.py"
        User time (seconds): 0.05
        System time (seconds): 0.00
        Percent of CPU this job got: 1%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 0:03.05
        Average shared text size (kbytes): 0
        Average unshared data size (kbytes): 0
        Average stack size (kbytes): 0
        Average total size (kbytes): 0
        Maximum resident set size (kbytes): 9244
        Average resident set size (kbytes): 0
        Major (requiring I/O) page faults: 0
        Minor (reclaiming a frame) page faults: 7979
        Voluntary context switches: 100
        Involuntary context switches: 1
        Swaps: 0
        File system inputs: 0
        File system outputs: 0
        Socket messages sent: 0
        Socket messages received: 0
        Signals delivered: 0
        Page size (bytes): 4096
        Exit status: 0
```
这里最有用的指标可能是 `Major (requiring I/O) page faults`，因为它指示了操作系统是否由于 RAM 中的数据不存在而需要从磁盘上读取页面。而这会带来速度上的惩罚。

我们的例子中对于代码和数据的需求较少，所以不会发生内存缺页错误。如果你有一个内存密集型进程，或多个需要分配和使用大量 RAM 的进程，你就会发现这个命令可以告诉你哪个进程会因为一部分 RAM 被交换到磁盘上这一额外的操作系统级别的磁盘访问而导致速度的下降。

### cProfile 模块

使用的演示代码还是和 [timeit 模块](#timeit-模块) 中的一样。

```bash
$ python -m cProfile test.py
cost 3.0033018589019775 seconds.
         8 function calls in 3.003 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    3.003    3.003 test.py:1(<module>)
        1    0.000    0.000    3.003    3.003 test.py:3(a)
        1    0.000    0.000    3.003    3.003 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 {built-in method builtins.print}
        1    3.003    3.003    3.003    3.003 {built-in method time.sleep}
        2    0.000    0.000    0.000    0.000 {built-in method time.time}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
```

输出结果：

- `ncalls`：函数被调用的次数。如果这一列有两个值，就表示有递归调用，第二个值是原生调用次数，第一个值是总调用次数
- `tottime`：函数内部消耗的总时间（可以帮助优化）
- `percall`：是 `tottime` 除以 `ncalls`，一个函数每次调用平均消耗时间
- `cumtime`：之前所有子函数消费时间的累计和
- `filename:lineno(function)`：被分析函数所在文件名、行号、函数名

可用参数：

- `-s cumulative`：对每个函数累计花费的时间进行排序
- `-o profile.stats`：将统计信息保存到 profile.stats 中
- ...

保存的统计信息可以用以下脚本来显示：

```python
import pstats
p = pstats.Stats("profile.stats")
# 按累计花费的时间进行排序
p.sort_stats("cumulative")
# 累计时间报告
p.print_stats()
# 被调用信息
p.print_callers()
# 调用信息
p.print_callees()
```
