# 函数

- [函数](#函数)
  - [参数](#参数)
  - [语句和表达式](#语句和表达式)
    - [语句](#语句)
    - [表达式](#表达式)
  - [具有返回值的函数](#具有返回值的函数)

使用 `fn` 关键字来声明新函数，`main` 函数是很多程序的入口点。

Rust 代码中的函数和变量名使用 `snake case` 规范风格。

```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
```

源码中 `another_function` 定义在 `main` 函数 之后；也可以定义在之前。Rust 不关心函数定义于何处，只要定义了就行。

## 参数

在函数定义中，必须声明每个参数的类型。当定义多个参数时，使用逗号分隔。

```rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
```

## 语句和表达式

函数体由一系列的语句和一个可选的结尾表达式构成。

- **语句（Statements）** 是执行一些操作但不返回值的指令。
- **表达式（Expressions）** 计算并产生一个值。

Rust 是一门 **基于表达式（expression-based）** 的语言，这是一个需要理解的（不同于其他语言）重要区别，其他语言并没有这样的区别。

### 语句

```rust
fn main() {
    let y = 6;
}
```

使用 `let` 关键字创建变量并绑定值是一个语句，函数定义也是语句。

语句不返回值。因此，不能把 `let` 语句赋值给另一个变量，如 `let x = (let y = 6);`。

`let y = 6` 语句并不返回值，所以没有可以绑定到 `x` 上的值。这与其他语言不同，例如 C 和 Ruby，它们的赋值语句会返回所赋的值。在这些语言中，可以这么写 `x = y = 6`，这样 `x` 和 `y` 的值都是 6。Rust 中不能这样写。

### 表达式

表达式会计算出一个值，并且你将编写的大部分 Rust 代码是由表达式组成的。

函数调用是一个表达式；宏调用是一个表达式；用大括号创建的一个新的块作用域也是一个表达式……

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```

这个表达式：

```rust
{
    let x = 3;
    x + 1
}
```

是一个代码块，它的值是 4。这个值作为 `let` 语句的一部分被绑定到 `y` 上。

`x+1` 这一行在结尾没有分号，与其他代码行不同。表达式的结尾没有分号。如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。

## 具有返回值的函数

函数可以向调用它的代码返回值。我们并不对返回值命名，但要在箭头 `->` 后声明它的类型。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 `return` 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。这是一个有返回值的函数的例子：

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```

在 `five` 函数中没有函数调用、宏、甚至没有 `let` 语句，只有数字 5。这在 Rust 中是一个完全有效的函数。注意，也指定了函数返回值的类型，就是 `-> i32`。

让我们仔细检查一下这段代码。有两个重要的部分：

1. `let x = five();` 这一行表明我们使用函数的返回值初始化一个变量。`five` 函数的返回值是 5，返回值类型是 `i32`。这一行与 `let x = 5;` 相同。
2. `five` 函数没有参数并定义了返回值类型，不过函数体只有单单一个 5 也没有分号，因为这是一个表达式，要返回它的值。

让我们看看另一个例子：

```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```

运行代码会打印出 `The value of x is: 6`。但如果在包含 `x + 1` 的行尾加上一个分号，把它从表达式变成语句，编译时将会报错 “mismatched types”（类型不匹配）。这揭示了代码的核心问题。函数 `plus_one` 的定义说明它要返回一个 `i32` 类型的值，不过语句并不会返回值，使用单位类型 `()` 表示不返回值。因为不返回值与函数定义相矛盾，从而出现一个错误。
