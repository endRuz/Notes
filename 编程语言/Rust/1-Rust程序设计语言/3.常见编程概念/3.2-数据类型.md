# 数据类型

- [数据类型](#数据类型)
  - [标量类型](#标量类型)
    - [整型](#整型)
      - [整型类型](#整型类型)
      - [整型字面值](#整型字面值)
      - [整型溢出](#整型溢出)
    - [浮点型](#浮点型)
    - [数值运算](#数值运算)


在 Rust 中，每一个值都属于某一个 **数据类型（data type）**，这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型子集：**标量（scalar）** 和 **复合（compound）**。

Rust 是 **静态类型（statically typed）** 语言，也就是说在编译时就必须知道所有变量的类型。

根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，就必须增加类型注解：

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

这里如果不添加类型注解，Rust 会显示如下错误，这说明编译器需要我们提供更多信息，来了解我们想要的类型：

```bash
$ cargo check
    Checking data_type v0.1.0 (/home/endruz/code/endruz/hello-rust/3.2/data_type)
error[E0282]: type annotations needed
  --> src/main.rs:13:9
   |
13 |     let guess = guess.trim().parse().expect("Please type a number!");
   |         ^^^^^ consider giving `guess` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `data_type` due to previous error
```

## 标量类型

**标量（scalar）** 类型代表一个单独的值。Rust 有四种基本的标量类型：

- 整型
- 浮点型
- 布尔类型
- 字符类型

### 整型

#### 整型类型

**整数** 是一个没有小数部分的数字。下表展示了 Rust 内建的整数类型。我们可以使用其中的任一个来声明一个整数值的类型。

| 长度    | 有符号 | 无符号 |
| :------ | :----- | :----- |
| 8-bit   | i8     | u8     |
| 16-bit  | i16    | u16    |
| 32-bit  | i32    | u32    |
| 64-bit  | i64    | u64    |
| 128-bit | i128   | u128   |
| arch    | isize  | usize  |

**有符号** 和 **无符号** 代表数字能否为负值，有符号数以 [补码形式（two’s complement representation）](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8) 存储。

各类型的取值范围如下（$n$ 为整型的位数）：

- 有符号的整型取值范围为 $[-(2^{n - 1}), 2^{n - 1} - 1]$
- 无符号的整型取值范围为 $[0, 2^{n} - 1]$

另外，`isize` 和 `usize` 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。

#### 整型字面值

| 数字字面值                  | 例子        |
| :-------------------------- | :---------- |
| Decimal (十进制)            | 98_222      |
| Hex (十六进制)              | 0xff        |
| Octal (八进制)              | 0o77        |
| Binary (二进制)             | 0b1111_0000 |
| Byte (单字节字符)(仅限于u8) | b'A'        |

多种数字类型的数字字面值允许使用类型后缀，例如 `57u8` 来指定 `u8` 类型的 57，同时也允许使用 `_` 做为分隔符以方便读数，例如 `1_000`，它的值与你指定的 `1000` 相同。

#### 整型溢出

比方说有一个 `u8` ，它可以存放从零到 255 的值。那么当你将其修改为 256 时会发生什么呢？这被称为 **整型溢出（integer overflow）**，这会导致以下两种行为之一的发生。

- 当在 debug 模式编译时，Rust 检查这类问题并使程序 panic（这个术语被 Rust 用来表明程序因错误而退出）。
- 在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码包装（two’s complement wrapping）的操作。简而言之，值 256 变成 0，值 257 变成 1，依此类推。

依赖整型溢出被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，[Wrapping](https://doc.rust-lang.org/std/num/struct.Wrapping.html)。 为了显式地处理溢出的可能性，你可以使用标准库在原生数值类型上提供的以下方法:

- 所有模式下都可以使用 `wrapping_*` 方法进行包装，如 `wrapping_add`
- 如果 `check_*` 方法出现溢出，则返回 None 值
- 用 `overflowing_*` 方法返回值和一个布尔值，表示是否出现溢出
- 用 `saturating_*` 方法在值的最小值或最大值处进行饱和处理

### 浮点型

Rust 也有两个原生的 **浮点数（floating-point numbers）** 类型，它们是带小数点的数字。Rust 的浮点数类型是 `f32` 和 `f64`，分别占 32 位和 64 位。默认类型是 `f64`，因为在现代 CPU 中，它与 `f32` 速度几乎一样，不过精度更高。所有的浮点型都是有符号的。

浮点数采用 IEEE-754 标准表示。`f32` 是单精度浮点数，`f64` 是双精度浮点数。

### 数值运算

Rust 中的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。

整数除法会向下舍入到最接近的整数。

```rust
fn main() {
    // 加法
    let sum = 5 + 10;

    // 减法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // 结果为 0

    // 取余
    let remainder = 43 % 5;
}
```
