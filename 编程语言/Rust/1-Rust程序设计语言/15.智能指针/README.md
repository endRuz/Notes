# 15. 智能指针
---

- [15.1 使用Box \<T\>指向堆上的数据](./15.1-使用Box%20<T>指向堆上的数据.md)
- [15.2 通过 Deref trait 将智能指针当作常规引用处理](./15.2-通过%20Deref%20trait%20将智能指针当作常规引用处理.md)
- [15.3 使用 Drop Trait 运行清理代码](./15.3-使用%20Drop%20Trait%20运行清理代码.md)
- [15.4 Rc\<T\> 引用计数智能指针](./15.4-Rc<T>%20引用计数智能指针.md)
- [15.5 RefCell\<T\> 和内部可变性模式](./15.5-RefCell<T>%20和内部可变性模式.md)
- [15.6 引用循环与内存泄漏](./15.6-引用循环与内存泄漏.md)


**指针 （pointer）** 是一个包含内存地址的变量的通用概念。这个地址引用，或 “指向”（points at）一些其他数据。Rust 中最常见的指针是 **引用（reference）**。引用以 `&` 符号为标志并借用了他们所指向的值。除了引用数据没有任何其他特殊功能。它们也没有任何额外开销，所以应用得最多。

另一方面，**智能指针（smart pointers）** 是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。Rust 标准库中不同的智能指针提供了多于引用的额外功能。例如 **引用计数 （reference counting）** 智能指针类型，其允许数据有多个所有者。引用计数智能指针记录总共有多少个所有者，并当没有任何所有者时负责清理数据。

在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反，在大部分情况下，智能指针拥有他们指向的数据。

实际我们已经遇见过一些智能指针，比如 `String` 和 `Vec<T>`。这些类型都属于智能指针因为它们拥有一些数据并允许你修改它们。它们也带有元数据（比如他们的容量）和额外的功能或保证（`String` 的数据总是有效的 UTF-8 编码）。

智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了 `Deref` 和 `Drop` trait：

- `Deref` trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码。
- `Drop` trait 允许我们自定义当智能指针离开作用域时运行的代码。

考虑到智能指针是一个在 Rust 经常被使用的通用设计模式，本章并不会覆盖所有现存的智能指针。很多库都有自己的智能指针而你也可以编写属于你自己的智能指针。这里将会讲到的是来自标准库中最常用的一些：

- `Box<T>`，用于在堆上分配值
- `Rc<T>`，一个引用计数类型，其数据可以有多个所有者
- `Ref<T>` 和 `RefMut<T>`，通过 `RefCell<T>` 访问。（ `RefCell<T>` 是一个在运行时而不是在编译时执行借用规则的类型）。

另外我们会涉及 **内部可变性（interior mutability）** 模式，这是不可变类型暴露出改变其内部值的 API。我们也会讨论 **引用循环（reference cycles）** 会如何泄漏内存，以及如何避免。
