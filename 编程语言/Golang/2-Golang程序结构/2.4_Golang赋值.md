# Golang 赋值

- [Golang 赋值](#golang-赋值)
  - [赋值](#赋值)
  - [赋值运算符](#赋值运算符)
  - [自增自减](#自增自减)
  - [元组赋值](#元组赋值)
  - [可赋值性](#可赋值性)

## 赋值

使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在 `=` 的左边，新值的表达式放在 `=` 的右边。最简单的赋值语句如下：

```go
var i int
i = 1
```

## 赋值运算符

特定的二元算术运算符和赋值语句的复合操作有一个简洁形式：

```go
i += 2 // i = i + 2
i *= 2 // i = i * 2
```

这样可以省去对变量表达式的重复计算。

| 赋值运算符 | 描述           | 实例                          |
| :--------: | :------------- | :---------------------------- |
|    `+=`    | 相加后再赋值   | `i += 2` 相当于 `i = i + 2`   |
|    `-=`    | 相减后再赋值   | `i -= 2` 相当于 `i = i - 2`   |
|    `*=`    | 相乘后再赋值   | `i *= 2` 相当于 `i = i * 2`   |
|    `/=`    | 相除后再赋值   | `i /= 2` 相当于 `i = i / 2`   |
|    `%=`    | 取余后再赋值   | `i %= 2` 相当于 `i = i % 2`   |
|   `<<=`    | 左移后再赋值   | `i <<= 2` 相当于 `i = i << 2` |
|   `>>=`    | 右移后再赋值   | `i >>= 2` 相当于 `i = i >> 2` |
|    `&=`    | 按位与后再赋值 | `i &= 2` 相当于 `i = i & 2`   |
|    `^=`    | 按位异后再赋值 | `i ^= 2` 相当于 `i = i ^ 2`   |
|   `\|=`    | 按位或后再赋值 | `i \|= 2` 相当于 `i = i \| 2` |

## 自增自减

数值变量也可以支持 `++` 自增和 `--` 自减语句：

```go
i := 1
i++    // 等价方式 i = i + 1；i 变成 2
i--    // 等价方式 i = i - 1；i 变成 1
```

> **注：** 自增和自减是 **语句** ，而不是表达式，因此 `x = i++` 之类的表达式是错误的

## 元组赋值

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样交换两个变量的值：

```go
x, y = y, x
```

有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时，左边变量的数目必须和右边一致。

```go
f, err = os.Open("foo.txt") // function call returns two values
```

我们可以用下划线空白标识符 `_` 来丢弃不需要的值。

```go
_, err = io.Copy(dst, src) // 丢弃字节数
_, ok = x.(T)              // 只检测类型，忽略具体值
```

## 可赋值性

赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为，例如：

- 函数调用会隐式地将调用参数的值赋值给函数的参数变量
- 一个返回语句会隐式地将返回操作的值赋值给结果变量
- 一个复合类型的字面量也会产生赋值行为。

例如下面的语句：

```go
medals := []string{"gold", "silver", "bronze"}
```

隐式地对slice的每个元素进行赋值操作，类似这样写的行为：

```go
medals[0] = "gold"
medals[1] = "silver"
medals[2] = "bronze"
```

`map` 和 `chan` 的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。

不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。

可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，`nil` 可以赋值给任何指针或引用类型的变量。常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。

对于两个值是否可以用 `==` 或 `!=` 进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。和前面一样，我们会对每个新类型比较特殊的地方做专门的解释。
