# Golang 变量

- [Golang 变量](#golang-变量)
  - [变量声明](#变量声明)
  - [简短变量声明](#简短变量声明)
  - [指针](#指针)
  - [new 函数](#new-函数)
  - [变量的生命周期](#变量的生命周期)


## 变量声明

`var` 是变量声明的关键词，变量声明的一般语法如下：

```go
var 变量名字 类型 = 表达式
```

其中 `类型` 或 `= 表达式` 两个部分可以省略其中的一个。

- 如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。
- 如果初始化表达式被省略，那么将用零值初始化该变量。

| 类型                                               | 零值  |
| :------------------------------------------------- | :---- |
| 数值类型                                           | 0     |
| 布尔类型                                           | false |
| 字符串类型                                         | ""    |
| 接口或引用类型（包括slice、指针、map、chan和函数） | nil   |

> **注：** 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：

```go
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：

```go
var f, err = os.Open(name) // os.Open returns a file and an error
```

## 简短变量声明

除 `var` 关键字外，还可使用更加简短的变量定义和初始化语法。

```go
名字 := 表达式
```

> **注：** 简短变量声明只能用在 **函数内部**。

同样也可以在一个声明语句中同时声明一组变量：

```go
i, j := 0, 1
```

## 指针

Golang 中在变量名前添加 `&` 来获取变量的内存地址，在指针前添加 `*` 来取指针所指向内存地址的值。

指针对应的数据类型是 `*T`（`T` 为指针指向变量的类型），被称之为“指向 T 类型的指针”。

```go
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
```

## new 函数

Golang 也可以调用内建的 `new` 函数创建变量。表达式 `new(T)` 将创建一个 `T` 类型的匿名变量，初始化为 `T` 类型的零值，然后返回变量地址，返回的指针类型为 `*T`。

```go
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
```

## 变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间段。

对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

> **注：** 与 Python 不同，Golang 中 `for` 循环中创建的是局部变量。

Golang 的自动垃圾收集器基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。
