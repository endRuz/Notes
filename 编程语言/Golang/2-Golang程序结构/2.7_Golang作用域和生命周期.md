# Golang 作用域和生命周期

- [Golang 作用域和生命周期](#golang-作用域和生命周期)
  - [作用域](#作用域)
    - [全局作用域](#全局作用域)
    - [局部作用域](#局部作用域)
      - [显式作用域](#显式作用域)
      - [隐式作用域](#隐式作用域)
  - [生命周期](#生命周期)
  - [作用域和生命周期区别](#作用域和生命周期区别)

## 作用域

一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。

### 全局作用域

Golang 的全局作用域包含：

- 对于内置的类型、函数和常量，比如 `int`、`len` 和 `true` 等，可以在整个程序中直接使用。
- 任何在函数外部（也就是包级）声明的名字可以在同一个包的任何源文件中访问的。
- 对于导入的包，例如导入的 `fmt` 包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的 `fmt` 包，当前包的其它源文件无法访问在当前源文件导入的包。

> **注：** 包级声明的名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的，那么它可以被外部的包访问。

在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。

### 局部作用域

局部作用域主要分为两部分：`显式作用域` 和 `隐式作用域`。

#### 显式作用域

显式作用域是被大括号包含的代码块。

比如函数中声明的变量，则是在局部作用域的，它只能在函数内部访问。

#### 隐式作用域

并不是所有的局部作用域都显式地对应到由大括号包含的语句；还有一些隐含的规则。

例如 `for` 语句创建了两个词法域：

1. 显式的部分是大括号包含的 `for` 的循环体部分词法域。
2. 隐式的部分则是循环的初始化部分，比如用于迭代变量 `i` 的初始化。

隐式的词法域部分的作用域还包含条件测试部分和循环后的迭代部分（`i++`），当然也包含循环体词法域。

```go
func hello1() {
    x := "hello!"
    for i := 0; i < len(x); i++ {
        x := x[i]
        if x != '!' {
            x := x + 'A' - 'a'
            fmt.Printf("%c", x) // "HELLO" (one letter per iteration)
        }
    }
}

// 同上
func hello2() {
    x := "hello"
    for _, x := range x {
        x := x + 'A' - 'a'
        fmt.Printf("%c", x) // "HELLO" (one letter per iteration)
    }
}
```

和 `for` 循环类似，`if` 和 `switch` 语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。

下面的 `if-else` 测试链演示了 `x` 和 `y` 的有效作用域范围：

```go
if x := f(); x == 0 {
    fmt.Println(x)
} else if y := g(x); x == y {
    fmt.Println(x, y)
} else {
    fmt.Println(x, y)
}
fmt.Println(x, y) // compile error: x and y are not visible here
```

## 生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间段。

对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

> **注：** 与 Python 不同，Golang 中 `for` 循环中创建的是局部变量。

Golang 的自动垃圾收集器基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

## 作用域和生命周期区别

1. 声明语句的**作用域**对应的是一个源代码的文本区域；它是一个**编译时**的属性。
2. 一个变量的**生命周期**是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个**运行时**的概念。
